/*
RSACipher.cpp - George Wood
*/

#include <random>
#include <math.h>
#include <climits>
#include <iostream>
#include "gmp/gmp.h"
#include "bigint/BigUnsignedInABase.hh"
#include "RSACipher.hpp"
using namespace std;

/*Default constructor for the RSA cipher*/
RSACipher::RSACipher()
{

}

/*Constructor for specified nLen*/
RSACipher::RSACipher(int inputNLen)
{
  if (inputNLen == nLen0 || inputNLen == nLen1 || inputNLen == nLen2)
  {
    nLen = inputNLen;
    securityStrength = validPairs.at(inputNLen);
  }
  else
  {
    cout << "Invalid nLen input. Please try a different option." << endl;
  }
}

//TODO hash alg
BigUnsigned RSACipher::hashAlg(BigUnsigned inputX)
{
  BigUnsigned test;
  return test;
}

//TODO approved RBG
string RSACipher::genRandBits(int stringSize)
{
  string outputString = "";
  for (int i = 0; i < stringSize; i++)
  {
    outputString += to_string(rand() % 2);
  }
  return outputString;
}

vector<BigUnsigned> sieveProcedure(BigUnsigned limitVal)
{
  vector<BigUnsigned> primes;
  int p = 2;
  for (BigUnsigned i = p; i < limitVal; i++)
  {

  }
  return primes;
}

bool primalityTest(BigUnsigned potentialPrime)
{
  //TODO 1. Prepare a table of primes less than sqrt(c) using the sieve procedure in (C.8)
  vector<BigUnsigned> smallerPrimes = sieveProcedure(modexp(potentialPrime, 1/2, 1));
  //2. Divide potential prime by all values in table. If divisible, return failure
  //3. If not divisible, return success

  return true;
}

//Appendix C.6 0 Shawe-Taylor Random Prime Routine
bool RSACipher::randomPrime(int length, BigUnsigned inputSeed,
  BigUnsigned& outputPrime, BigUnsigned& primeSeed)
{
  BigUnsigned c;
  BigUnsigned primeGenCounter;
  //1. If (length < 2), then return failure
  if (length < 2)
  {
    return false;
  }
  //2. If (length ≥ 33), then go to step 14.
  if (length < 33)
  {
    //3. primeSeed = inputSeed
    primeSeed = inputSeed;
    //4. primeGenCounter = 0;
    primeGenCounter = 0;

    bool loopStep5 = true;
    while (loopStep5)
    {
      //5. c = hashAlg(primeSeed)^hashAlg(primeSeed + 1)

      c.bitXor(hashAlg(primeSeed), hashAlg(primeSeed + 1));
      //6. c = 2^length-1 + (c mod 2^length-1)
      c = modexp(2, length - 1, 1) + modexp(c, 1, modexp(2, length - 1, 1));
      //7. c = (2 * floor(c / 2)) + 1
      c = (floor(c / 2) * 2) + 1;
      //8.primeGenCounter++
      primeGenCounter++;
      //9.primeSeed += 2
      primeSeed += 2;
      //10. TODO prove that c is prime, appendix c.7
      //11. if c is prime,
      if (primalityTest(c))
      {
        //11.1&2 outputPrime = c, return success
        outputPrime = c;
        return true;
      }

      //12. if primeGenCounter > 4*length, return failure
      if (primeGenCounter > (4 * length))
      {
        return false;
      }
      //13. Go to step 5
    }
  }
  //14. randomPrime((length / 2) + 1, inputSeed)
  BigUnsigned c0;
  if (!randomPrime(floor(length / 2) + 1, inputSeed, c0, primeSeed))
  {
    //15. If failure is returned, return failure
    return false;
  }
  //16. iterations = ceil(length / outlen) - 1;
  int iterations = ceil(length / outLen) - 1;
  //17. oldCounter = primeGenCounter
  BigUnsigned oldCounter = primeGenCounter;
  //18. x = 0
  BigUnsigned x = 0;
  //19. For i = 0 to iterations, do x += hashAlg(primeSeed + i) * 2^i*outlen
  for (int i = 0; i < iterations; i++)
  {
    x += hashAlg(primeSeed + i) * modexp(2, i * outLen, 1);
  }
  //20. primeSeed += iterations + 1
  primeSeed += iterations + 1;
  //21. x = 2^length-1 + x mod 2^(length-1)
  x = modexp(2, length - 1, 1) + modexp(x, 1, modexp(2, length - 1, 1));
  //22.t = ceil(x / 2 * c0)

  BigUnsigned t = ceil(x / c0 * 2);
  while (true)
  {
    //23. if (2 * t * c0) + 1 > 2^length) then t = [2^length-1 / (2 * c0)]
    if (((t * c0 * 2) + 1) > modexp(2, length, 1))
    {
      t = ceil(modexp(2, length - 1, 1) / (c0 * 2));
    }
    //24. c = 2tc0 + 1
    c = (t * c0 * 2) + 1;
    //25. primeGenCounter++
    primeGenCounter++;
    //26. a = 0
    BigUnsigned a = 0;
    //27. For i = 0 to iterations, do:
    for (int i = 0; i < iterations; i++)
    {
      //a += hashAlg(primeSeed + i) * 2^i*outlen
      a += hashAlg(primeSeed + i) * modexp(2, i * outLen, 1);
    }
    //28. primeSeed += iterations + 1
    primeSeed += iterations + 1;
    //29. a = 2 + a mod (c - 3)
    a = modexp(a, 1, (c - 3)) + 2;
    //30. z = a^2t mod c
    BigUnsigned z = modexp(a, t * 2, c);
    //31. if (gcd(z-1, c) == 1) and (z^c0 mod c == 1) then
    if ((gcd(z - 1, c) == 1) && (modexp(z, c0, c) == 1))
    {
      //31.1 prime = c
      outputPrime = c;
      //31.2 return success
      return true;
    }
    //32. if primeGenCounter >= (4 * length + oldCounter) return failure
    if (primeGenCounter >= (oldCounter + (length * 4)))
    {
      return false;
    }
    //33. t++
    t++;
    //34. Go to step 23
  }
}

bool RSACipher::genFirstSeed(BigUnsigned& seed)
{
  //1. If invalid nLen, return failure (done in constructor)
  //2. Set security_strength to corresponding val for nLen (done in constructor)
  //3. Obtain (2 * security_strength) bit string from a valid RBG
  BigUnsignedInABase binarySeed =
    BigUnsignedInABase(genRandBits(securityStrength * 2), 2);
  seed = BigUnsigned(binarySeed);

  //4. Return success
  return true;
}

//Appendix C.10
bool RSACipher::genPrimeFromAuxiliaries(int l, int n1, int n2,
  BigUnsigned firstSeed, BigUnsigned e, BigUnsigned &outputSeed)
{
  BigUnsigned p0;
  BigUnsigned p1;
  BigUnsigned p2;
  BigUnsigned pSeed;
  BigUnsigned p0Seed;
  BigUnsigned p1Seed;
  BigUnsigned p2Seed;

  //1. If l, n1, or n2 are not valid, return failure (already handled)
  //2. If n1 == 1
  if (n1 == 1)
  {
    //2.1 p1 = 1
    p1 = 1;
    //2.2 p2Seed = firstSeed
    p2Seed = firstSeed;
  }
  //TODO 3. If n1 >= 2
  else if (n1 >= 2)
  {
    //3.1  Using n1 as the length and firstSeed as the input_seed, use the random prime
    // generation routine in Appendix C.6 to obtain p1 and p2Seed.
    //3.2 If failure is returned, return failure
    if (!randomPrime(n1, firstSeed, p1, p2Seed))
    {
      return false;
    }
  }
  //4. If n2 == 1
  if (n2 == 1)
  {
    //4.1 p2 = 1
    p2 = 1;
    //4.2 p0Seed = p2Seed
    p0Seed = p2Seed;
  }
  //TODO 5. If n2 >= 2
  else if (n2 >= 2)
  {
    //5.1  Using n2 as the length and p2Seed as the inputSeed, use the random prime
    // generation routine in Appendix C.6 to obtain p2 and p0Seed.
    //5.2 If fairlure is returned, return failure
    if (!randomPrime(n2, p2Seed, p2, p0Seed))
    {
      return false;
    }
  }
  //6. TODO Using ceil(l / 2) + 1 as the length and p0Seed as the inputSeed, use the random prime
  //generation routine in Appendix C.6 to obtain p0 and pSeed. If failure is returned,
  //then return failure
  if (!randomPrime(ceil(l/2) + 1, p0Seed, p0, pSeed))
  {
    return false;
  }
  //TODO 7. 7. iterations = ceil(l / outLen) − 1
  //TODO what is outLen?
  int iterations = ceil(l / outLen) - 1;
  //8. pGenCounter = 0
  BigUnsigned pGenCounter = 0;
  //9. x = 0
  BigUnsigned x = 0;
  //10. For i = 0 to iterations: x = x + (hashAlg(pSeed + i)) ∗ 2^(i * outLen)
  for (int i = 0; i < iterations; i++)
  {
    x += hashAlg(pSeed + 1) * modexp(2, i * outLen, 1);
  }
  //11. pSeed = pSeed + iterations + 1.
  pSeed += iterations + 1;
  //12. x = floor(sqrt(2)*(2^(l−1))) + (x mod (2^(l) − floor(sqrt(2)(2^(l−1)))))
  x = floor((modexp(2, l - 1, 1)) * sqrt(2)) + modexp(x, 1, modexp(2, l ,1)) -
    floor(sqrt(2) * modexp(2, l-1, 1));
  //13. If (gcd(p0*p1, p2) ≠ 1), then return failure
  if (gcd(p0 * p1, p2) != 1)
  {
    return false;
  }
  //TODO 14. Compute y in the interval [1, p2] such that 0 = ( y*p0*p1–1) mod p2.
  BigUnsigned y;
  //15. t = ceil(((2*y*p0*p1) + x)/(2*p0*p1*p2)).
  BigUnsigned t = ceil(((y * p0 * p1 * 2) + x) / (p0 * p1 * p2 * 2));
  while (true)
  {
    //16. If ((2(t*p2 − y)*p0*p1 + 1) > 2^l)
    if (((t * p2 - y) * p0 * p1 * 2 + 1) > modexp(2, l, 1))
    {
      //then t = ceil((2*y*p0*p1) + floor((sqrt(2))(2^(l−1))) / (2*p0*p1*p2))
      t = ceil((y * 2 * p0 * p1) + floor(modexp(2, l - 1, 1)) / (p0 * p1 * p2 * 2));
    }
    //17. p = 2(t*p2 − y)*p0*p1 + 1.
    p = (t * p2 - y) * p0 * p1 * 2 + 1;
    //18. pGenCounter = pGenCounter + 1.
    pGenCounter++;
    //19. If (GCD(p–1, e) = 1), then
    if (gcd(p - 1, e) == 1)
    {
      //19.1 a = 0
      BigUnsigned a = 0;
      //19.2 For i = 0 to iterations do: a = a + (Hash(pseed + i))∗ 2 i * outlen.
      for (int i = 0; i < iterations; i++)
      {
        a += hashAlg(pSeed + 1) * modexp(2, i * outLen, 1);
      }
      //19.3 pSeed = pSeed + iterations + 1.
      pSeed += iterations + 1;
      //19.4 a = 2 + (a mod (p–3)).
      a = modexp(a, 1, p - 3) + 2;
      //19.5 z = a^(2(t*p2 − y)*p1) mod p.
      BigUnsigned z = modexp(a, (t * p2 - y) * p1 * 2, p);
      //19.6 If ((1 = GCD(z–1, p)) and (1 = (z^(p0) mod p)), then return success
      if ((gcd(z - 1, p) == 1) && (modexp(z, p0, p) == 1))
      {
        return true;
      }
      //20. If (pgen_counter ≥ 5L), then return failure
      if (pGenCounter >= l * 5)
      {
        return false;
      }
      //21. t = t + 1
      t++;
      //22. Go to step 16.
    }
    pGenCounter++;
    return true;
  }
}

/*
Generates the p & q, the seeds needed for RSA key generation.
seedLen must be larger than N.
*/
bool RSACipher::genPrimes(BigUnsigned e, BigUnsigned seed,
  BigUnsigned& p, BigUnsigned& q)
{
  //1. If nLen isn't 2048 nor 3072, then return (FAILURE, 0, 0) (separate func)
  if (nLen != nLen1 && nLen != nLen2)
  {
    return false;
  }
  //2. If (e ≤ 2^16 OR e ≥ 2^256 OR e is not odd), then return failure
  if ((e <= modexp(2, 16, 1)) || (e >= modexp(2, 256, 1)) || (modexp(e, 1, 2) != 1))
  {
    return false;
  }
  //3. Set securityStrength to appropriate val (handled in constructor)

  //4. If (len(seed) != 2 * securityStrength), then return failure (handled in constructor)

  //5. working_seed = seed.
  BigUnsigned workingSeed = seed;

  BigUnsigned pSeed;
  BigUnsigned qSeed;
  BigUnsigned firstSeed = workingSeed;

  //6. Generate p:
  //6.1 Using l = nlen/2, n1 = 1, n2 = 1, firstSeed = working_seed and e,
  //use the provable prime construction method in Appendix C.10 to obtain p and
  //pSeed. If failure is returned, then return failure

  int l = nLen / 2;
  int n1 = 1;
  int n2 = 1;

  if (!genPrimeFromAuxiliaries(l, n1, n2, firstSeed, e, pSeed))
  {
    cout << "Generation of the seed for prime p generation failed!" << endl;
    return false;
  }

  //6.2 working_seed = pseed.
  workingSeed = pSeed;

  BigUnsigned absVal = 0;
  BigUnsigned comparisonVal = modexp(2, ((nLen / 2) - 100), 1);
  while(absVal <= comparisonVal)
  {
    //7. Generate q:
    //7.1 Using L = nlen/2, N1 = 1, N2 = 1, first_seed = working_seed and e,
    //use the provable prime construction method in Appendix C.10 to obtain q
    // and qseed. If FAILURE is returned, then return (FAILURE, 0, 0).
    //TODO appendix c.10 alg, reinitialize L and Ns if needed

    //7.2 working_seed = qseed.
    workingSeed = qSeed;
    //BigInteger has no abs val, so have to subtract this way

    if (p > q)
    {
      absVal = p - q;
    }
    else
    {
      absVal = q - p;
    }
    //8. If ( |p – q| ≤ 2^(nlen/2 – 100)), then go to step 7.
  }

  //9. Zeroize the internally generated seeds: (Not needed)
  //10. Return (SUCCESS, p, q).
  return true;
}

bool RSACipher::genRSAKeys()
{
  //Initializes seed for random number gen
  random_device randSeeder;
  //Creates random generator engine using Mersenne-Twister engine
  //TODO investigate what this is
  mt19937 numGen(randSeeder());
  //Number distribution to select from, 'guaranteed unbiased'
  uniform_int_distribution<int> unbiasedGen(pow(2, 16), UINT_MAX);

  //Gets randomized e value, must be odd
  //TODO must be declared later, if FIPS allows for it
  e = 0;
  while  (e <= modexp(2, 16, 1)  || (e >= modexp(2, 256, 1)) ||
    (modexp(e, 1, 2) != 1))
  {
    e = unbiasedGen(numGen);
  }

  //Primes used for calculating n
  BigUnsigned p;
  BigUnsigned q;

  

  //Seed used for generating primes
  BigUnsigned seed;

  //Generates seed for prime generation
  if(!genFirstSeed(seed))
  {
    cout << "Generation of the first prime generation seed failed!" << endl;
    return false;
  }
  //Generates primes p and q for key generation
  if(!genPrimes(e, seed, p, q))
  {
    cout << "Generation of prime values p & q failed!" << endl;
    return false;
  }
  //Gets n value
  BigUnsigned n = p * q;
  //Gets phi value for n
  BigUnsigned phiN = (p - 1) * (q - 1);

  //Gets private key (d)
  d = modinv(e, phiN);

  //Returns success
  return true;
}

//TODO input text separated into blocks
bool RSACipher::encrypt(BigUnsigned e, BigUnsigned n, string plainText)
{
  BigUnsigned binaryPlainText;
  BigUnsigned binarycryptText = modexp(binaryPlainText, e, n);
  return true;
}

bool RSACipher::decrypt(BigUnsigned d, BigUnsigned n, string cryptText)
{
  BigUnsigned binaryCryptText;
  BigUnsigned binaryPlainText = modexp(binaryCryptText, d, n);
  return true;
}

